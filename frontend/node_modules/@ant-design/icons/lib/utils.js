"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    warning: function() {
        return warning;
    },
    isIconDefinition: function() {
        return isIconDefinition;
    },
    normalizeAttrs: function() {
        return normalizeAttrs;
    },
    generate: function() {
        return generate;
    },
    getSecondaryColor: function() {
        return getSecondaryColor;
    },
    normalizeTwoToneColors: function() {
        return normalizeTwoToneColors;
    },
    svgBaseProps: function() {
        return svgBaseProps;
    },
    iconStyles: function() {
        return iconStyles;
    },
    useInsertStyles: function() {
        return useInsertStyles;
    }
});
const _colors = require("@ant-design/colors");
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _warning = /*#__PURE__*/ _interop_require_default(require("rc-util/lib/warning"));
const _dynamicCSS = require("rc-util/lib/Dom/dynamicCSS");
const _shadow = require("rc-util/lib/Dom/shadow");
const _Context = /*#__PURE__*/ _interop_require_default(require("./components/Context"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function warning(valid, message) {
    (0, _warning.default)(valid, `[@ant-design/icons] ${message}`);
}
function isIconDefinition(target) {
    return typeof target === "object" && typeof target.name === "string" && typeof target.theme === "string" && (typeof target.icon === "object" || typeof target.icon === "function");
}
function normalizeAttrs(attrs = {}) {
    return Object.keys(attrs).reduce((acc, key)=>{
        const val = attrs[key];
        switch(key){
            case "class":
                acc.className = val;
                delete acc.class;
                break;
            default:
                acc[key] = val;
        }
        return acc;
    }, {});
}
function generate(node, key, rootProps) {
    if (!rootProps) {
        return _react.default.createElement(node.tag, {
            key,
            ...normalizeAttrs(node.attrs)
        }, (node.children || []).map((child, index)=>generate(child, `${key}-${node.tag}-${index}`)));
    }
    return _react.default.createElement(node.tag, {
        key,
        ...normalizeAttrs(node.attrs),
        ...rootProps
    }, (node.children || []).map((child, index)=>generate(child, `${key}-${node.tag}-${index}`)));
}
function getSecondaryColor(primaryColor) {
    // choose the second color
    return (0, _colors.generate)(primaryColor)[0];
}
function normalizeTwoToneColors(twoToneColor) {
    if (!twoToneColor) {
        return [];
    }
    return Array.isArray(twoToneColor) ? twoToneColor : [
        twoToneColor
    ];
}
const svgBaseProps = {
    width: "1em",
    height: "1em",
    fill: "currentColor",
    "aria-hidden": "true",
    focusable: "false"
};
const iconStyles = `
.anticon {
  display: inline-block;
  color: inherit;
  font-style: normal;
  line-height: 0;
  text-align: center;
  text-transform: none;
  vertical-align: -0.125em;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.anticon > * {
  line-height: 1;
}

.anticon svg {
  display: inline-block;
}

.anticon::before {
  display: none;
}

.anticon .anticon-icon {
  display: block;
}

.anticon[tabindex] {
  cursor: pointer;
}

.anticon-spin::before,
.anticon-spin {
  display: inline-block;
  -webkit-animation: loadingCircle 1s infinite linear;
  animation: loadingCircle 1s infinite linear;
}

@-webkit-keyframes loadingCircle {
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}

@keyframes loadingCircle {
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}
`;
const useInsertStyles = (eleRef)=>{
    const { csp, prefixCls } = (0, _react.useContext)(_Context.default);
    let mergedStyleStr = iconStyles;
    if (prefixCls) {
        mergedStyleStr = mergedStyleStr.replace(/anticon/g, prefixCls);
    }
    (0, _react.useEffect)(()=>{
        const ele = eleRef.current;
        const shadowRoot = (0, _shadow.getShadowRoot)(ele);
        (0, _dynamicCSS.updateCSS)(mergedStyleStr, "@ant-design-icons", {
            prepend: true,
            csp,
            attachTo: shadowRoot
        });
    }, []);
};
